#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This module is in the public domain.  No warranties.
'''Usage: milky filename.mk
Milky the Indentation-based Language liKe pYthon, yet a C preprocessor.'''

__author__  = 'Arnie97 <me@arnie97.progr.am>'
__version__ = '0.1.2-build20150109'


import sys
import re
from subprocess import *
from pprint import pprint

lines = ['']
indent_stack = [0]
indent_type = {}
tokens = (
    'if', 'else', 'elif',
    'while', 'until', 'for',
    'switch', 'def'
)


def indent(line):
    'Calculate indent of specified line.'
    line = line.expandtabs()
    return len(line) - len(line.lstrip())


def lex():
    'Generate C-style blocks with line numbers kept.'
    with open(filename) as file:
        line, quit = __author__, False
        while 1:
            line = file.readline()
            if quit:
                break
            elif len(line) == 0:
                quit = True
            elif line.isspace():
                continue
            else:
                line = line[:-1]
            current_indent = indent(line)
            if current_indent > indent_stack[-1]:  # indent
                indent_stack.append(current_indent)
                indent_type[current_indent] = 0
                if 'case' in lines[-1] or 'default' in lines[-1]:
                    indent_type[current_indent] = -1
                elif 'until' in lines[-1]:
                    indent_type[current_indent] = lines[-1].strip().replace('until', 'while (')
                    lines[-1] = ' ' * indent_stack[-1] + 'do {'
                else:
                    # TODO: add parenthesis before block statements
                    lines[-1] = lines[-1].replace(':', '') + ' {'
                # for token in tokens:
                #     re.search(r'\W%s\W' % token, lines[-1])
            elif current_indent < indent_stack[-1]:  # dedent
                if lines[-1].lstrip()[0] != '#' and lines[-1].lstrip():
                    lines[-1] += ';'
                while current_indent < indent_stack[-1]:
                    if indent_type[indent_stack[-1]] == -1:
                        if 'fallthrough' in line[-1]:
                            # TODO: fallthrough
                            line[-1] = line[-1].replace('fall', '')
                        elif 'case' in line or 'default' in line:
                            lines[-1] += ' break;'
                        else:
                            lines[-1] += ' }'
                        indent_type[indent_stack[-1]] = 0
                    elif indent_type[indent_stack[-1]]:  # until
                        lines[-1] += ' } ' + indent_type[indent_stack[-1]] + ');'
                        indent_type[indent_stack[-1]] = 0
                    else:
                        lines[-1] += ' }'
                    indent_stack.pop()
            elif 'switch' in lines[-1]:
                lines[-1] = lines[-1].replace(':', '') + ' {'
            # TODO: backslashed line and true lexer
            # elif line[-1] == '\\':  # backslashed line
                # line = line[:-1] + file.readline()
            elif lines[-1].lstrip() and lines[-1].lstrip()[0] != '#':
                lines[-1] += ';'
            lines.append(line)


def parser():
    lines.pop(0)
    print('\n'.join(lines))


def wait_for(timeout=None):
    'Closure for a non-blocking timer. Accepts 0 which means never expires.'
    if timeout:
        timeout = monotonic() + timeout
        return lambda: monotonic() > timeout
    else:
        return lambda: False


if __name__ != '__main__':
    try:
        argv = sys.argv[1].lower()
        if argv in ('-i', '--interrupt'):
            pass
        elif argv in ('-?', '--help', '/?'):
            sys.stdout.write(__doc__)
        elif argv:
            raise IndexError
    except IndexError:
        sys.stdout.write('Illegal Arguments.\n%s\n' % __doc__)
    except KeyboardInterrupt:
        sys.exit(0)

filename = 'foobar.milk'
lex()
parser()
